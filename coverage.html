
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>sources: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/phantom820/streams/sources/sources.go (95.5%)</option>
				
				<option value="file1">github.com/phantom820/streams/streams/concurrent_stream.go (99.0%)</option>
				
				<option value="file2">github.com/phantom820/streams/streams/errors.go (92.9%)</option>
				
				<option value="file3">github.com/phantom820/streams/streams/pipeline.go (100.0%)</option>
				
				<option value="file4">github.com/phantom820/streams/streams/sequential_stream.go (99.3%)</option>
				
				<option value="file5">github.com/phantom820/streams/streams/stream.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package sources

import (
        "errors"
        "fmt"
        "math"
)

// Source a source of elements for a stream. Sources can come from a slice, collection etc and can be finite/infinite/
type Source[T any] interface {
        Next() T       // Returns the next element from the source.
        HasNext() bool // Checks if the Source has a next element to produce.
}

// PartitionedSource a source that is made up of disjoint sources that can be processed independently.
type PartionedSource[T any] interface {
        At(i int) Source[T]  // Returns the i'th partition of the source.
        Len() int            // Returns the number of partitions the source has.
        Partition(n int) int // Partitions the source into n parttions
}

// collectSource returns a slice containing all the elements from the source.
func collectSource[T any](source Source[T]) []T <span class="cov3" title="6">{
        data := make([]T, 0)
        for source.HasNext() </span><span class="cov10" title="2020">{
                data = append(data, source.Next())
        }</span>
        <span class="cov3" title="6">return data</span>
}

// NewPartitionedSource creates a new partitioned source from the given source.
func NewPartitionedSource[T any](source Source[T]) PartionedSource[T] <span class="cov1" title="1">{
        return &amp;partitionedSource[T]{source: source, sources: make([]Source[T], 0)}
}</span>

// partitionedSource a source that is made up of disjoint sources that can be processed independently.
type partitionedSource[T any] struct {
        source  Source[T]
        sources []Source[T]
}

// Partition returns a partioned source with na partitions. The input source must be finite otherwise will run into an infinite loop when trying
// to collect it into a slice.
func (partitionedSource *partitionedSource[T]) Partition(n int) int <span class="cov2" title="3">{
        data := collectSource(partitionedSource.source)
        partitionSize := int(math.Ceil(float64(len(data)) / float64(n))) // Do we need smarter ways of picking the partition size here.
        sources := make([]Source[T], 0)
        for i := 0; i &lt; len(data); i = i + partitionSize </span><span class="cov4" title="13">{
                var partition []T
                if i+partitionSize &gt;= len(data) </span><span class="cov2" title="3">{
                        partition = data[i:]
                }</span> else<span class="cov3" title="10"> {
                        partition = data[i : i+partitionSize]
                }</span>
                <span class="cov4" title="13">source := NewSourceFromSlice(func() []T </span><span class="cov2" title="3">{ return partition }</span>)
                <span class="cov4" title="13">sources = append(sources, source)</span>
        }
        <span class="cov2" title="3">partitionedSource.sources = sources
        return len(sources)</span>
}

// At returns the partition at the i'th index and will panic if the index is out of bounds.
func (partitionedSource *partitionedSource[T]) At(i int) Source[T] <span class="cov2" title="4">{
        if i &gt;= len(partitionedSource.sources) </span><span class="cov1" title="1">{
                err := fmt.Sprintf("ErrIndexOutOfBounds: Index: %v, Size: %v", i, len(partitionedSource.sources))
                panic(errors.New(err))</span>
        }
        <span class="cov2" title="3">return partitionedSource.sources[i]</span>
}

// Len returns the number of partitions the source has.
func (partitionedSource *partitionedSource[T]) Len() int <span class="cov1" title="2">{
        return len(partitionedSource.sources)
}</span>

// source a sequential stream source.
type source[T any] struct {
        next    func() T
        hasNext func() bool
}

// HasNext checks if the source has a next element to produce.
func (source *source[T]) HasNext() bool <span class="cov4" title="13">{
        return source.hasNext()
}</span>

// Next returns the next element from the source.
func (source *source[T]) Next() T <span class="cov3" title="10">{
        return source.next()
}</span>

// NewSource creates a new sequential source.
func NewSource[T any](next func() T, hasNext func() bool) Source[T] <span class="cov0" title="0">{
        return &amp;source[T]{next: next, hasNext: hasNext}
}</span>

// NewSourceFromSlice creates a sequential source from a slice.
func NewSourceFromSlice[T any](f func() []T) Source[T] <span class="cov4" title="13">{
        var data []T
        initialized := false
        i := 0
        hasNext := func() bool </span><span class="cov4" title="23">{
                if !initialized </span><span class="cov2" title="3">{
                        initialized = true
                        data = f()
                }</span>
                <span class="cov4" title="23">if data == nil || i &gt;= len(data) </span><span class="cov2" title="3">{
                        return false
                }</span>
                <span class="cov4" title="20">return true</span>
        }
        <span class="cov4" title="13">next := func() T </span><span class="cov3" title="10">{
                if !hasNext() </span><span class="cov0" title="0">{
                        panic(errors.New("ErrNoNextElement"))</span>
                }
                <span class="cov3" title="10">element := data[i]
                i++
                return element</span>
        }
        <span class="cov4" title="13">source := source[T]{next: next, hasNext: hasNext}
        return &amp;source</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// package streams provides java motivated stream implementation.
package streams

import (
        "fmt"
        "sync"
        "sync/atomic"

        "github.com/phantom820/collections"
        "github.com/phantom820/collections/sets/hashset"
        "github.com/phantom820/collections/types"
        "github.com/phantom820/streams/sources"
)

// concurrentSTream represent a stream implementation in which elements can be operated on concurrently. The underlying source has to be finite in order
// to avoid an infinite loop when trying to split stream elements for concurrent processing.
type concurrentStream[T any] struct {
        maxcConcurrency int                   // maximum number of go routines to use when processing the stream
        distinct        bool                  // indicates if the stream consist of distinct elements only , i.e say we constructed this from a set.
        terminated      bool                  // indicates whether a terminal operation was invoked on the stream.
        closed          bool                  // indicates whether the stream has been closed , all streams are auto closed once a terminal operation is invoked.
        completed       func(i int) bool      // checks if the stream has completed processing all elements.
        pipeline        func(i int) (T, bool) // pipeline of the operations.
        partition       func() int            // partitions the source and returns the number of partitions.
}

// terminate this terinates the stream and sets its source to nil.
func (stream *concurrentStream[T]) terminate() <span class="cov6" title="1019">{
        stream.terminated = true
        stream.closed = true
        stream.pipeline = nil
        stream.completed = nil
        stream.partition = nil
}</span>

// closes the stream, i,e another stream has been derived from it.
func (stream *concurrentStream[T]) close() <span class="cov6" title="1016">{
        stream.closed = true
}</span>

// Concurrent always returns false for a sequential stream.
func (stream *concurrentStream[T]) Concurrent() bool <span class="cov1" title="3">{
        return true
}</span>

// Terminated checks if a terminal operation has been invoked on the stream.
func (stream *concurrentStream[T]) Terminated() bool <span class="cov7" title="4072">{
        return stream.terminated
}</span>

// Closed check if the stream has been closed, a stream is closed when another stream was derived from it, a terminated stream is closed also.
func (stream *concurrentStream[T]) Closed() bool <span class="cov7" title="3046">{
        return stream.closed
}</span>

// valid if a stream is valid for any type of operation.
func (stream *concurrentStream[T]) valid() (bool, *Error) <span class="cov7" title="2047">{
        if stream.Terminated() </span><span class="cov2" title="9">{
                err := ErrStreamTerminated()
                return false, &amp;err
        }</span> else<span class="cov7" title="2038"> if stream.Closed() </span><span class="cov1" title="1">{
                err := ErrStreamClosed()
                return false, &amp;err
        }</span>
        <span class="cov7" title="2037">return true, nil</span>
}

// getPipeline returns the pipeline of operations of the stream.
func (stream *concurrentStream[T]) getPipeline() func(i int) (T, bool) <span class="cov9" title="54302">{
        return stream.pipeline
}</span>

//  concurrentFromCollection creates a sconcurrent tream from the given collection. All changes made to the collection before the stream is terminated
// are visible to the stream
func concurrentFromCollection[T types.Equitable[T]](collection collections.Collection[T], maxConcurrency int) Stream[T] <span class="cov2" title="9">{
        it := collection.Iterator()
        source := sources.NewSource(it.Next, it.HasNext)
        concurrentSource := sources.NewPartitionedSource(source)
        stream := &amp;concurrentStream[T]{
                pipeline:  emptyConcurrentPipeline(concurrentSource),
                completed: func(i int) bool </span><span class="cov4" title="78">{ return !(concurrentSource.At(i).HasNext()) }</span>,
                partition: func() int <span class="cov2" title="8">{ return concurrentSource.Partition(maxConcurrency) }</span>,
        }
        <span class="cov2" title="9">return stream</span>
}

// concurrentFromSlice creates a concurrent stream by using the callback to retrieve the underlying slice. All changes made to the slice before the stream is terminated
// are visible to the stream.
func concurrentFromSlice[T any](f func() []T, maxConcurrency int) Stream[T] <span class="cov2" title="5">{
        source := sources.NewSourceFromSlice(f)
        concurrentSource := sources.NewPartitionedSource(source)
        stream := concurrentStream[T]{
                pipeline:  emptyConcurrentPipeline(concurrentSource),
                completed: func(i int) bool </span><span class="cov3" title="29">{ return !(concurrentSource.At(i).HasNext()) }</span>,
                partition: func() int <span class="cov2" title="4">{ return concurrentSource.Partition(maxConcurrency) }</span>,
        }
        <span class="cov2" title="5">return &amp;stream</span>
}

// concurrentFromSource creates a concurrent stream from the given source.
func concurrentFromSource[T any](source sources.Source[T], maxConcurrency int) Stream[T] <span class="cov6" title="1011">{
        concurrentSource := sources.NewPartitionedSource(source)
        stream := &amp;concurrentStream[T]{
                pipeline:  emptyConcurrentPipeline(concurrentSource),
                completed: func(i int) bool </span><span class="cov10" title="57452">{ return !(concurrentSource.At(i).HasNext()) }</span>,
                partition: func() int <span class="cov6" title="1007">{ return concurrentSource.Partition(maxConcurrency) }</span>,
        }
        <span class="cov6" title="1011">return stream</span>
}

// Map returns a stream containing the results of applying the given mapping function to the elements of the stream. Applying this operation results in
// the underlying type of the stream being an interface since receiver methods do not support generic types.
func (inputStream *concurrentStream[T]) Map(f func(x T) interface{}) Stream[interface{}] <span class="cov2" title="5">{
        if ok, err := inputStream.valid(); !ok </span><span class="cov1" title="2">{
                panic(err)</span>
        }
        <span class="cov1" title="3">defer inputStream.close()
        newStream := concurrentStream[interface{}]{
                pipeline: func(i int) (interface{}, bool) </span><span class="cov3" title="24">{
                        element, ok := inputStream.pipeline(i)
                        if !ok </span><span class="cov2" title="9">{
                                var sentinel interface{}
                                return sentinel, ok
                        }</span>
                        <span class="cov3" title="15">return f(element), ok</span>
                },
                distinct:  false,
                completed: inputStream.completed,
                partition: inputStream.partition,
        }
        <span class="cov1" title="3">return &amp;newStream</span>
}

// Filter returns a stream consisting of the elements of the stream that match the given predicate.
func (inputStream *concurrentStream[T]) Filter(f func(x T) bool) Stream[T] <span class="cov2" title="7">{
        if ok, err := inputStream.valid(); !ok </span><span class="cov1" title="1">{
                panic(err)</span>
        }
        <span class="cov2" title="6">defer inputStream.close()
        newStream := concurrentStream[T]{
                pipeline: func(i int) (T, bool) </span><span class="cov4" title="52">{
                        element, ok := inputStream.pipeline(i)
                        if !ok </span><span class="cov0" title="0">{
                                var sentinel T
                                return sentinel, ok
                        }</span> else<span class="cov4" title="52"> if !f(element) </span><span class="cov3" title="26">{
                                var sentinel T
                                return sentinel, false
                        }</span>
                        <span class="cov3" title="26">return element, true</span>
                },
                distinct:  inputStream.distinct,
                completed: inputStream.completed,
                partition: inputStream.partition,
        }
        <span class="cov2" title="6">return &amp;newStream</span>
}

// Returns a stream that is limited to only producing n elements. Will panic if limit is negative.
func (inputStream *concurrentStream[T]) Limit(limit int) Stream[T] <span class="cov6" title="1004">{
        if ok, err := inputStream.valid(); !ok </span><span class="cov1" title="1">{
                panic(err)</span>
        } else<span class="cov6" title="1003"> if limit &lt; 0 </span><span class="cov1" title="1">{
                panic(ErrIllegalArgument("Limit", fmt.Sprint(limit)))</span>
        }
        <span class="cov6" title="1002">defer inputStream.close()
        var counter uint32
        var mutex sync.Mutex
        newStream := concurrentStream[T]{
                pipeline: func(i int) (T, bool) </span><span class="cov9" title="54302">{
                        mutex.Lock()
                        defer mutex.Unlock()
                        element, ok := inputStream.getPipeline()(i)
                        if !ok </span><span class="cov1" title="3">{
                                return element, ok
                        }</span> else<span class="cov9" title="54299"> {
                                if int(atomic.LoadUint32(&amp;counter)) &lt; limit </span><span class="cov9" title="52539">{
                                        atomic.AddUint32(&amp;counter, 1)
                                        return element, true
                                }</span>
                                <span class="cov7" title="1760">return element, false</span>
                        }
                },
                completed: func(i int) bool <span class="cov9" title="57306">{
                        if inputStream.completed(i) || int(atomic.LoadUint32(&amp;counter)) &gt;= limit </span><span class="cov7" title="3004">{
                                return true
                        }</span>
                        <span class="cov9" title="54302">return false</span>
                },
                distinct:  inputStream.distinct,
                partition: inputStream.partition,
        }
        <span class="cov6" title="1002">return &amp;newStream</span>
}

// Returns a stream that skips the first n elements in processing. Will panic if number of elements to skip is negative.
func (inputStream *concurrentStream[T]) Skip(skip int) Stream[T] <span class="cov2" title="4">{
        if ok, err := inputStream.valid(); !ok </span><span class="cov1" title="1">{
                panic(err)</span>
        } else<span class="cov1" title="3"> if skip &lt; 0 </span><span class="cov1" title="1">{
                panic(ErrIllegalArgument("Skip", fmt.Sprint(skip)))</span>
        }
        <span class="cov1" title="2">defer inputStream.close()
        var counter uint32
        var mutex sync.Mutex
        newStream := concurrentStream[T]{
                pipeline: func(i int) (T, bool) </span><span class="cov3" title="19">{
                        mutex.Lock()
                        defer mutex.Unlock()
                        element, ok := inputStream.pipeline(i)
                        if !ok </span><span class="cov1" title="1">{
                                return element, ok
                        }</span> else<span class="cov3" title="18"> {
                                if int(atomic.LoadUint32(&amp;counter)) &lt; skip </span><span class="cov2" title="4">{
                                        atomic.AddUint32(&amp;counter, 1)
                                        return element, false
                                }</span>
                                <span class="cov3" title="14">return element, true</span>
                        }
                },
                distinct:  inputStream.distinct,
                completed: inputStream.completed,
                partition: inputStream.partition,
        }
        <span class="cov1" title="2">return &amp;newStream</span>
}

// Distinct returns a stream consisting of distinct elements. Elements are distinguished using equality and hash code.
func (inputStream *concurrentStream[T]) Distinct(equals func(x, y T) bool, hashCode func(x T) int) Stream[T] <span class="cov2" title="4">{
        if ok, err := inputStream.valid(); !ok </span><span class="cov1" title="1">{
                panic(err)</span>
        }
        <span class="cov1" title="3">defer inputStream.close()
        set := hashset.New[element[T]]()
        var mutex sync.Mutex
        newStream := concurrentStream[T]{
                pipeline: func(i int) (T, bool) </span><span class="cov3" title="30">{
                        mutex.Lock()
                        defer mutex.Unlock()
                        item, ok := inputStream.pipeline(i)
                        if !ok </span><span class="cov1" title="1">{
                                return item, false
                        }</span> else<span class="cov3" title="29"> if set.Contains(element[T]{value: item, equals: equals, hashCode: hashCode}) </span><span class="cov3" title="14">{
                                var sentinel T
                                return sentinel, false
                        }</span>
                        <span class="cov3" title="15">set.Add(element[T]{value: item, equals: equals, hashCode: hashCode})
                        return item, true</span>
                },
                distinct:  true,
                completed: inputStream.completed,
                partition: inputStream.partition,
        }
        <span class="cov1" title="3">return &amp;newStream</span>
}

// collect collects the result from a particular partition into a slice.
func collect[T any](wg *sync.WaitGroup, result chan []T, stream *concurrentStream[T], i int) <span class="cov7" title="3024">{
        defer wg.Done()
        data := make([]T, 0)
        for !stream.completed(i) </span><span class="cov9" title="54383">{
                element, ok := stream.pipeline(i)
                if ok </span><span class="cov9" title="52591">{
                        data = append(data, element)
                }</span>
        }
        <span class="cov7" title="3024">result &lt;- data</span>
}

// ForEach performs the given task on each element of the stream.
func (stream *concurrentStream[T]) ForEach(f func(element T)) <span class="cov6" title="1014">{
        if ok, err := stream.valid(); !ok </span><span class="cov1" title="2">{
                panic(err)</span>
        }
        <span class="cov6" title="1012">defer stream.terminate()
        var wg sync.WaitGroup
        n := stream.partition()
        results := make(chan []T, n)
        for i := 0; i &lt; n; i++ </span><span class="cov7" title="3024">{
                wg.Add(1)
                go collect(&amp;wg, results, stream, i)
        }</span>
        <span class="cov6" title="1012">wg.Wait()
        close(results)
        for result := range results </span><span class="cov7" title="3024">{
                for _, element := range result </span><span class="cov9" title="52591">{
                        f(element)
                }</span>
        }
}

// count performs a count of the number of elements in a partition.
func count[T any](wg *sync.WaitGroup, result chan int, stream *concurrentStream[T], i int) <span class="cov3" title="12">{
        defer wg.Done()
        count := 0
        for !stream.completed(i) </span><span class="cov3" title="37">{
                _, ok := stream.pipeline(i)
                if ok </span><span class="cov3" title="25">{
                        count++
                }</span>
        }
        <span class="cov3" title="12">result &lt;- count</span>
}

// Count returns a count of how many elements are in the stream.
func (stream *concurrentStream[T]) Count() int <span class="cov2" title="6">{
        if ok, err := stream.valid(); !ok </span><span class="cov1" title="1">{
                panic(err)</span>
        }
        <span class="cov2" title="5">defer stream.terminate()
        var wg sync.WaitGroup
        n := stream.partition()
        results := make(chan int, n)
        for i := 0; i &lt; n; i++ </span><span class="cov3" title="12">{
                wg.Add(1)
                go count(&amp;wg, results, stream, i)
        }</span>
        <span class="cov2" title="5">wg.Wait()
        close(results)
        count := 0
        for result := range results </span><span class="cov3" title="12">{
                count = count + result
        }</span>
        <span class="cov2" title="5">return count</span>
}

// reduce performs a reduction on a partition.
func reduce[T any](wg *sync.WaitGroup, result chan T, stream *concurrentStream[T], f func(x, y T) T, i int) <span class="cov1" title="3">{
        defer wg.Done()
        pipeline := stream.pipeline
        count := 0
        var x, y T
        for !stream.completed(i) </span><span class="cov4" title="100">{
                element, ok := pipeline(i)
                if ok </span><span class="cov4" title="100">{
                        switch count </span>{
                        case 0:<span class="cov1" title="3">
                                x = element
                                break</span>
                        case 1:<span class="cov1" title="3">
                                y = element
                                x = f(x, y)
                                break</span>
                        case 2:<span class="cov1" title="3">
                                x = f(x, element)
                                break</span>
                        default:<span class="cov4" title="91">
                                x = f(x, element)
                                break</span>
                        }
                        <span class="cov4" title="100">count++</span>
                }
        }
        <span class="cov1" title="3">if count &gt; 0 </span><span class="cov1" title="3">{
                result &lt;- x
        }</span>
}

// Reduce returns the result of applying the associative binary function on elements of the stream. The binary operator is only applied if the are
// at least 2 elements in the stream, in the case of 1 element , the element is returned. Otherwise the returned result is invalid and will be indicated by the second returned value.
func (stream *concurrentStream[T]) Reduce(f func(x, y T) T) (T, bool) <span class="cov1" title="3">{
        if ok, err := stream.valid(); !ok </span><span class="cov1" title="1">{
                panic(err)</span>
        }
        <span class="cov1" title="2">defer stream.terminate()
        var wg sync.WaitGroup
        n := stream.partition()
        results := make(chan T, n)
        for i := 0; i &lt; n; i++ </span><span class="cov1" title="3">{
                wg.Add(1)
                go reduce(&amp;wg, results, stream, f, i)
        }</span>
        <span class="cov1" title="2">wg.Wait()
        close(results)
        var x, y T
        count := 0
        for result := range results </span><span class="cov1" title="3">{
                if count == 0 </span><span class="cov1" title="1">{
                        x = result
                }</span> else<span class="cov1" title="2"> {
                        y = result
                        x = f(x, y)
                }</span>
                <span class="cov1" title="3">count++</span>
        }
        <span class="cov1" title="2">if count == 0 </span><span class="cov1" title="1">{
                var zero T
                return zero, false
        }</span>
        <span class="cov1" title="1">return x, true</span>
}

// Collect returns a slice containing the output elements of the stream.
func (stream *concurrentStream[T]) Collect() []T <span class="cov6" title="1011">{
        slice := make([]T, 0)
        stream.ForEach(func(element T) </span><span class="cov9" title="52581">{
                slice = append(slice, element)
        }</span>)
        <span class="cov6" title="1010">return slice</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package streams

import (
        "bytes"
        "text/template"
)

// error codes.
const (
        StreamTerminated = 1
        IllegalArgument  = 2
        StreamClosed     = 3
        IllegalConfig    = 4
)

// error templates.
var (
        StreamTerminatedTemplate, _ = template.New("StreamTerminated").Parse("ErrStreamTerminated: A terminal operation has been invoked on the stream.")
        IllegalArgumentTemplate, _  = template.New("IllegalArgument").Parse("ErrIllegalArgument: Illegal argument: {{.argument}} for operation: {{.operation}}.")
        StreamClosedTemplate, _     = template.New("StreamClosed").Parse("ErrStreamClosed: The stream has been closed.")
        IllegalConfigTemplate, _    = template.New("IllegalConfig").Parse("ErrIllegalStreamConfig: Illegal configuration {{.argument}} when trying to create a stream using {{.function}}")
)

// Error a custom error type for stream.
type Error struct {
        code int
        msg  string
        Err  error
}

// Code returns the error code for the error.
func (err Error) Code() int <span class="cov10" title="25">{
        return err.code
}</span>

// Error returns the error message.
func (err *Error) Error() string <span class="cov0" title="0">{
        return err.msg
}</span>

// ErrStreamTerminated returns an error for a  stream that has already been terminated.
func ErrStreamTerminated() Error <span class="cov8" title="17">{
        var buffer bytes.Buffer
        StreamTerminatedTemplate.Execute(&amp;buffer, map[string]int{})
        return Error{code: StreamTerminated, msg: buffer.String()}
}</span>

// ErrStreamClosed returns an error for a  stream that has been closed.
func ErrStreamClosed() Error <span class="cov2" title="2">{
        var buffer bytes.Buffer
        StreamClosedTemplate.Execute(&amp;buffer, map[string]int{})
        return Error{code: StreamClosed, msg: buffer.String()}
}</span>

// ErrIllegalArgument returns an error for a  stream operation that has been given an illegal argument.
func ErrIllegalArgument(argument, operation string) Error <span class="cov4" title="3">{
        var buffer bytes.Buffer
        IllegalArgumentTemplate.Execute(&amp;buffer, map[string]string{"argument": argument, "operation": operation})
        return Error{code: IllegalArgument, msg: buffer.String()}
}</span>

// ErrIllegalConfigu returns an error for trying to construct a stream with illegal concurrency.
func ErrIllegalConfig(config, function string) Error <span class="cov4" title="3">{
        var buffer bytes.Buffer
        IllegalConfigTemplate.Execute(&amp;buffer, map[string]string{"config": config, "function": function})
        return Error{code: IllegalConfig, msg: buffer.String()}
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package streams

import "github.com/phantom820/streams/sources"

// emptyPipeline returns the initial pipeline for a stream.
func emptyPipeline[T any](source sources.Source[T]) func() (T, bool) <span class="cov3" title="33">{
        return func() (T, bool) </span><span class="cov5" title="211">{
                return source.Next(), true
        }</span>

}

// emptyConcurrentPipeline returns the initial pipeline for a concurrent stream.
func emptyConcurrentPipeline[T any](source sources.PartionedSource[T]) func(i int) (T, bool) <span class="cov6" title="1025">{
        return func(i int) (T, bool) </span><span class="cov10" title="54520">{
                return source.At(i).Next(), true
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// package streams provides java motivated stream implementation.
package streams

import (
        "fmt"

        "github.com/phantom820/collections"
        "github.com/phantom820/collections/sets/hashset"
        "github.com/phantom820/collections/types"
        "github.com/phantom820/streams/sources"
)

// stream a sequential stream implementation. The stream is lazy evaluated and any modification made to its source before a terminal operation is invoked
// on the stream will be visible to the stream. A stream can be finite/ infinite based on ots source, for a infinite stream a limit operation shoudl always
// be applied to avoid an infinite loop when trying to process the stream.
type stream[T any] struct {
        terminated bool             // indicates whether the stream has been closed.
        closed     bool             // indicates whether the stream has been closed , all streams are auto closed once a terminal operation is invoked.
        completed  func() bool      // checks if the stream has completed processing all elements.
        pipeline   func() (T, bool) // pipeline of the operations.
}

// terminate this terminates the stream and sets some properties to nil.
func (stream *stream[T]) terminate() <span class="cov7" title="28">{
        stream.terminated = true
        stream.closed = true
        stream.pipeline = nil
        stream.completed = nil
}</span>

// Concurrent always returns false for a sequential stream.
func (stream *stream[T]) Concurrent() bool <span class="cov2" title="3">{
        return false
}</span>

// closes the stream, i,e another stream has been derived from it.
func (stream *stream[T]) close() <span class="cov6" title="24">{
        stream.closed = true
}</span>

// Closed chekcs if the stream is closed which means that another stream was derived from it.
func (stream *stream[T]) Closed() bool <span class="cov8" title="74">{
        return stream.closed
}</span>

// Terminated checks if a terminal operation has been invoked on the stream.
func (stream *stream[T]) Terminated() bool <span class="cov9" title="91">{
        return stream.terminated
}</span>

// valid if a stream is valid for any type of operation.
func (stream *stream[T]) valid() (bool, *Error) <span class="cov8" title="62">{
        if stream.Terminated() </span><span class="cov4" title="8">{
                err := ErrStreamTerminated()
                return false, &amp;err
        }</span> else<span class="cov8" title="54"> if stream.Closed() </span><span class="cov1" title="1">{
                err := ErrStreamClosed()
                return false, &amp;err
        }</span>
        <span class="cov8" title="53">return true, nil</span>
}

// getPipeline returns the pipeline of operations of the stream.
func (stream *stream[T]) getPipeline() func() (T, bool) <span class="cov9" title="142">{
        return stream.pipeline
}</span>

// fromSource creates a stream from the given source. The source can be finite/ infinite.
func fromSource[T any](source sources.Source[T]) Stream[T] <span class="cov6" title="19">{
        stream := &amp;stream[T]{
                pipeline:   emptyPipeline(source),
                completed:  func() bool </span><span class="cov10" title="145">{ return !(source.HasNext()) }</span>,
                terminated: false,
        }
        <span class="cov6" title="19">return stream</span>
}

// fromCollection creates a stream from the given collection. All changes made to the collection before the stream is terminated
// are visible to the stream. Creating from a specific collection is recommended i.e FromSet .
func fromCollection[T types.Equitable[T]](collection collections.Collection[T]) Stream[T] <span class="cov5" title="10">{
        it := collection.Iterator()
        source := sources.NewSource(it.Next, it.HasNext)

        stream := &amp;stream[T]{
                pipeline:   emptyPipeline(source),
                completed:  func() bool </span><span class="cov8" title="78">{ return !(source.HasNext()) }</span>,
                terminated: false,
        }
        <span class="cov5" title="10">return stream</span>
}

// fromSlice creates a stream by using the callback to retrieve the underlying slice. All changes made to the slice before the stream is terminated
// are visible to the stream.
func fromSlice[T any](f func() []T) Stream[T] <span class="cov3" title="4">{
        source := sources.NewSourceFromSlice(f)
        stream := stream[T]{
                pipeline:   emptyPipeline(source),
                completed:  func() bool </span><span class="cov6" title="16">{ return !(source.HasNext()) }</span>,
                terminated: false,
        }
        <span class="cov3" title="4">return &amp;stream</span>
}

// Map returns a stream containing the results of applying the given mapping function to the elements of the stream. Applying this operation results in
// the underlying type of the stream being an interface since receiver methods do not support generic types.
func (inputStream *stream[T]) Map(f func(x T) interface{}) Stream[interface{}] <span class="cov3" title="5">{
        if ok, err := inputStream.valid(); !ok </span><span class="cov2" title="2">{
                panic(err)</span>
        }
        <span class="cov2" title="3">defer inputStream.close()
        newStream := stream[interface{}]{
                pipeline: func() (interface{}, bool) </span><span class="cov8" title="51">{
                        element, ok := inputStream.getPipeline()()
                        if !ok </span><span class="cov6" title="27">{
                                var sentinel interface{}
                                return sentinel, ok
                        }</span>
                        <span class="cov6" title="24">return f(element), ok</span>
                },
                completed:  inputStream.completed,
                terminated: false,
        }
        <span class="cov2" title="3">return &amp;newStream</span>
}

// Filter returns a stream consisting of the elements of the stream that match the given predicate.
func (inputStream *stream[T]) Filter(f func(x T) bool) Stream[T] <span class="cov4" title="9">{
        if ok, err := inputStream.valid(); !ok </span><span class="cov1" title="1">{
                panic(err)</span>
        }
        <span class="cov4" title="8">defer inputStream.close()
        newStream := stream[T]{
                pipeline: func() (T, bool) </span><span class="cov9" title="89">{
                        element, ok := inputStream.pipeline()
                        if !ok </span><span class="cov5" title="10">{
                                var sentinel T
                                return sentinel, ok
                        }</span> else<span class="cov8" title="79"> if !f(element) </span><span class="cov7" title="36">{
                                var sentinel T
                                return sentinel, false
                        }</span>
                        <span class="cov7" title="43">return element, true</span>
                },
                completed:  inputStream.completed,
                terminated: false,
        }
        <span class="cov4" title="8">return &amp;newStream</span>
}

// Returns a stream that is limited to only producing n elements. Will panic if limit is negative.
func (inputStream *stream[T]) Limit(limit int) Stream[T] <span class="cov4" title="8">{
        if ok, err := inputStream.valid(); !ok </span><span class="cov1" title="1">{
                panic(err)</span>
        } else<span class="cov4" title="7"> if limit &lt; 0 </span><span class="cov1" title="1">{
                panic(ErrIllegalArgument("Limit", fmt.Sprint(limit)))</span>
        }
        <span class="cov4" title="6">defer inputStream.close()
        n := 0
        newStream := stream[T]{
                pipeline: func() (T, bool) </span><span class="cov8" title="63">{
                        element, ok := inputStream.getPipeline()()
                        if !ok </span><span class="cov7" title="29">{
                                return element, ok
                        }</span> else<span class="cov7" title="34"> {
                                if n &lt; limit </span><span class="cov7" title="34">{
                                        n++
                                        return element, true
                                }</span>
                                <span class="cov0" title="0">return element, false</span>
                        }
                },
                completed: func() bool <span class="cov8" title="69">{
                        if inputStream.completed() || n &gt;= limit </span><span class="cov4" title="6">{
                                return true
                        }</span>
                        <span class="cov8" title="63">return false</span>
                },
                terminated: false,
        }
        <span class="cov4" title="6">return &amp;newStream</span>
}

// Returns a stream that skips the first n elements in processing. Will panic if number of elements to skip is negative.
func (inputStream *stream[T]) Skip(skip int) Stream[T] <span class="cov3" title="5">{
        if ok, err := inputStream.valid(); !ok </span><span class="cov1" title="1">{
                panic(err)</span>
        }
        <span class="cov3" title="4">defer inputStream.close()
        skipped := 0
        newStream := stream[T]{
                pipeline: func() (T, bool) </span><span class="cov7" title="40">{
                        element, ok := inputStream.pipeline()
                        if !ok </span><span class="cov1" title="1">{
                                return element, ok
                        }</span> else<span class="cov7" title="39"> {
                                if skipped &lt; skip </span><span class="cov5" title="14">{
                                        skipped++
                                        return element, false
                                }</span>
                                <span class="cov6" title="25">return element, true</span>
                        }
                },
                completed:  inputStream.completed,
                terminated: false,
        }
        <span class="cov3" title="4">return &amp;newStream</span>
}

// element this type allows us to use sets for the Distinct operation.
type element[T any] struct {
        value    T
        equals   func(a, b T) bool
        hashCode func(a T) int
}

// Equals required by Hashable for using a set.
func (a element[T]) Equals(b element[T]) bool <span class="cov7" title="28">{
        return a.equals(a.value, b.value)
}</span>

// HashCode produces the hash code of the element.
func (a element[T]) HashCode() int <span class="cov9" title="118">{
        return a.hashCode(a.value)
}</span>

// Distinct returns a stream consisting of distinct elements. Elements are distinguished using equality and hash code.
func (inputStream *stream[T]) Distinct(equals func(x, y T) bool, hashCode func(x T) int) Stream[T] <span class="cov3" title="4">{
        if ok, err := inputStream.valid(); !ok </span><span class="cov1" title="1">{
                panic(err)</span>
        }
        <span class="cov2" title="3">defer inputStream.close()
        set := hashset.New[element[T]]()
        newStream := stream[T]{
                pipeline: func() (T, bool) </span><span class="cov7" title="30">{
                        item, ok := inputStream.pipeline()
                        if !ok </span><span class="cov1" title="1">{
                                return item, false
                        }</span> else<span class="cov7" title="29"> if set.Contains(element[T]{value: item, equals: equals, hashCode: hashCode}) </span><span class="cov5" title="14">{
                                var sentinel T
                                return sentinel, false
                        }</span>
                        <span class="cov5" title="15">set.Add(element[T]{value: item, equals: equals, hashCode: hashCode})
                        return item, true</span>
                },
                completed:  inputStream.completed,
                terminated: false,
        }
        <span class="cov2" title="3">return &amp;newStream</span>
}

// ForEach performs the given task on each element of the stream.
func (stream *stream[T]) ForEach(f func(element T)) <span class="cov6" title="17">{
        if ok, err := stream.valid(); !ok </span><span class="cov1" title="1">{
                panic(err)</span>
        }
        <span class="cov6" title="16">defer stream.terminate()
        pipeline := stream.getPipeline()
        for !stream.completed() </span><span class="cov9" title="115">{
                element, ok := pipeline()
                if ok </span><span class="cov9" title="92">{
                        f(element)
                }</span>
        }
}

// Count returns a count of how many elements are in the stream.
func (stream *stream[T]) Count() int <span class="cov4" title="7">{
        if ok, err := stream.valid(); !ok </span><span class="cov1" title="1">{
                panic(err)</span>
        }
        <span class="cov4" title="6">defer stream.terminate()
        count := 0
        pipeline := stream.getPipeline()
        for !stream.completed() </span><span class="cov7" title="43">{
                _, ok := pipeline()
                if ok </span><span class="cov7" title="29">{
                        count++
                }</span>
        }
        <span class="cov4" title="6">return count</span>
}

// Reduce returns the result of applying the associative binary function on elements of the stream. The binary operator is only applied if the are
// at least 2 elements in the stream, otherwise the returned result is invalid and will be indicated by the second returned value.
func (stream *stream[T]) Reduce(f func(x, y T) T) (T, bool) <span class="cov4" title="7">{
        if ok, err := stream.valid(); !ok </span><span class="cov1" title="1">{
                panic(err)</span>
        }
        <span class="cov4" title="6">defer stream.terminate()
        pipeline := stream.getPipeline()
        count := 0
        var x, y T
        for !stream.completed() </span><span class="cov8" title="53">{
                element, ok := pipeline()
                if ok </span><span class="cov6" title="26">{
                        switch count </span>{
                        case 0:<span class="cov3" title="5">
                                x = element
                                break</span>
                        case 1:<span class="cov2" title="3">
                                y = element
                                x = f(x, y)
                                break</span>
                        case 2:<span class="cov2" title="3">
                                x = f(x, element)
                                break</span>
                        default:<span class="cov5" title="15">
                                x = f(x, element)
                                break</span>
                        }
                        <span class="cov6" title="26">count++</span>
                }
        }

        <span class="cov4" title="6">if count &lt; 1 </span><span class="cov1" title="1">{
                var zero T
                return zero, false
        }</span>

        <span class="cov3" title="5">return x, true</span>
}

// Collect returns a slice containing the output elements of the stream.
func (stream *stream[T]) Collect() []T <span class="cov5" title="15">{
        slice := make([]T, 0)
        stream.ForEach(func(element T) </span><span class="cov9" title="86">{
                slice = append(slice, element)
        }</span>)
        <span class="cov5" title="15">return slice</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package streams

import (
        _ "embed"
        "fmt"

        "github.com/phantom820/collections"
        "github.com/phantom820/collections/types"
        "github.com/phantom820/streams/sources"
)

// Stream a sequence of elements that can be operated on sequential / concurrently.
type Stream[T any] interface {

        // Intermediate operations.
        Filter(f func(x T) bool) Stream[T]                               // Returns a stream consisting of the elements of this stream that satisfy the given predicate.
        Map(f func(x T) interface{}) Stream[interface{}]                 // Returns a stream consisting of the results of applying the given function to the elements of the stream.
        Limit(n int) Stream[T]                                           // Returns a stream consisting of the elements of the stream but only limited to processing n elements.
        Skip(n int) Stream[T]                                            // Returns a stream that skips the first n elements it encounters in processing.
        Distinct(equals func(x, y T) bool, hash func(x T) int) Stream[T] // Returns a stream consisting of distinct elements. Elements are distinguished using equality and hash code.

        // Terminal operations.
        ForEach(f func(x T))               // Performs an action specified by the function f for each element of this stream.
        Count() int                        // Returns a count of elements in the stream.
        Reduce(f func(x, y T) T) (T, bool) // Returns the result of appying a reduction on the elements of the stream. If the stream has no elements then the result would
        // be invalid and the zero value for T along with false would be returned.
        Collect() []T // Returns a slice containing the elements from the stream.

        // Util.
        Terminated() bool // Checks if a terminal operation has been invoked on the stream.
        Closed() bool     // Checks if a stream has been closed. In stream is closed either when a new stream is created from it using intermediate
        // operations, terminated streams are also closed.
        Concurrent() bool // Checks if the stream has a max concurrency &gt; 1 or not.
}

// NewFromCollection creates a stream from the given collection with the specified levele of concurrency. If the concurrency is set to 1
// then the resulting stream is sequential otherwise for values &gt; 1 it is concurrent stream that use no more than the specified number of go routines
// when processing the stream.
func NewFromCollection[T types.Equitable[T]](collection collections.Collection[T], maxConcurrency int) Stream[T] <span class="cov10" title="3">{
        if maxConcurrency &lt; 1 </span><span class="cov1" title="1">{
                panic(ErrIllegalConfig(fmt.Sprintf("maxConcurrency=%v", maxConcurrency), "FromCollection"))</span>
        }
        <span class="cov6" title="2">if maxConcurrency == 1 </span><span class="cov1" title="1">{
                return fromCollection(collection)
        }</span>
        <span class="cov1" title="1">return concurrentFromCollection(collection, maxConcurrency)</span>
}

// NewFromSlice creates a stream which will use the slice obtained from the callback. The callback is invoked only when a terminal operation is used on the stream.
//  If the concurrency is set to 1 then the resulting stream is sequential otherwise for values &gt; 1 it is concurrent stream that use no more than the specified number of go routines
// when processing the stream.
func NewFromSlice[T any](f func() []T, maxConcurrency int) Stream[T] <span class="cov10" title="3">{
        if maxConcurrency &lt; 1 </span><span class="cov1" title="1">{
                panic(ErrIllegalConfig(fmt.Sprintf("maxConcurrency=%v", maxConcurrency), "FromSlice"))</span>
        }
        <span class="cov6" title="2">if maxConcurrency == 1 </span><span class="cov1" title="1">{
                return fromSlice(f)
        }</span>
        <span class="cov1" title="1">return concurrentFromSlice(f, maxConcurrency)</span>
}

// NewFromSource creates a stream from the given collection with the specified level of concurrency. If the concurrency is set to 1
// then the resulting stream is sequential otherwise for values &gt; 1 it is concurrent stream that use no more than the specified number of go routines
// when processing the stream. An infinite source should only be used when the stream is sequential and a limit operation will be applied on it,
// otherwise we will run into an infinite loop in trying to use a concurrent stream with an infinite source even if we apply limit.
func NewFromSource[T any](source sources.Source[T], maxConcurrency int) Stream[T] <span class="cov10" title="3">{
        if maxConcurrency &lt; 1 </span><span class="cov1" title="1">{
                panic(ErrIllegalConfig(fmt.Sprintf("maxConcurrency=%v", maxConcurrency), "FromSource"))</span>
        }
        <span class="cov6" title="2">if maxConcurrency == 1 </span><span class="cov1" title="1">{
                return fromSource(source)
        }</span>
        <span class="cov1" title="1">return concurrentFromSource(source, maxConcurrency)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
